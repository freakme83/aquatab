<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zen Akvaryum: State & Trait Sim</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: #020617;
      color: #f8fafc;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    #aquarium-wrapper {
      position: relative;
      width: 92vw;
      max-width: 1200px;
      height: 72vh;
      background: linear-gradient(180deg, #1e40af 0%, #1e3a8a 100%);
      border: 8px solid #334155;
      border-radius: 20px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      display: grid;
      grid-template-columns: 1fr 320px; /* sağ panel sabit */
    }

    /* SOL: akvaryum sahnesi */
    #scene {
      position: relative;
      overflow: hidden;
    }
    canvas { display: block; }

    #sand {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
      background: #ca8a04;
      border-top: 4px solid #a16207;
      z-index: 10;
      pointer-events: none;
    }

    #aquarium-timer {
      position: absolute;
      bottom: 70px;
      right: 14px;
      z-index: 50;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.35);
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 0.78rem;
      color: rgba(255, 255, 255, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.12);
      pointer-events: none;
    }

    /* SAĞ: sürekli açık “Zen Panel” */
    #sidepanel {
      border-left: 1px solid rgba(255,255,255,0.12);
      background: rgba(15, 23, 42, 0.92);
      backdrop-filter: blur(10px);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .tabbar {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .tabbtn {
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(30, 41, 59, 0.55);
      padding: 10px 10px;
      border-radius: 12px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.12s ease;
    }
    .tabbtn:hover { transform: translateY(-1px); background: rgba(30, 41, 59, 0.75); }
    .tabbtn.active { background: rgba(59, 130, 246, 0.28); border-color: rgba(59,130,246,0.5); }

    .panel {
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px;
      background: rgba(2,6,23,0.25);
    }
    .panel h2 {
      margin: 0 0 10px 0;
      font-size: 1.05rem;
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    .kv {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-size: 0.86rem;
    }
    .muted { opacity: 0.75; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .btnrow {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }
    .btn {
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(30,41,59,0.55);
      border-radius: 12px;
      padding: 10px;
      font-size: 0.86rem;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.12s ease;
    }
    .btn:hover { background: rgba(30,41,59,0.75); transform: translateY(-1px); }
    .btn.primary { background: rgba(37,99,235,0.65); border-color: rgba(37,99,235,0.55); }
    .btn.primary:hover { background: rgba(37,99,235,0.78); }
    .btn.teal { background: rgba(13,148,136,0.6); border-color: rgba(13,148,136,0.55); }
    .btn.teal:hover { background: rgba(13,148,136,0.75); }
    .btn.danger { background: rgba(127,29,29,0.35); border-color: rgba(185,28,28,0.35); }
    .btn.danger:hover { background: rgba(127,29,29,0.5); }

    input[type="range"] { width: 100%; }

    .shopbtn {
      width: 100%;
      text-align: left;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(30,41,59,0.35);
      border-radius: 14px;
      padding: 12px;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.12s ease;
    }
    .shopbtn:hover { background: rgba(30,41,59,0.55); transform: translateY(-1px); }
    .shopbtn:disabled { opacity: 0.35; cursor: not-allowed; transform: none; }

    /* baloncuklar */
    .bubble {
      position: absolute;
      background: rgba(255, 255, 255, 0.20);
      border-radius: 50%;
      pointer-events: none;
      animation: rise 8s linear infinite;
      z-index: 2;
    }
    @keyframes rise {
      0% { transform: translateY(120%) scale(1); opacity: 0; }
      50% { opacity: 0.35; }
      100% { transform: translateY(-220px) scale(1.5); opacity: 0; }
    }

    .notification {
      position: fixed;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.92);
      padding: 8px 14px;
      border-radius: 999px;
      z-index: 1000;
      font-size: 0.82rem;
      border: 1px solid rgba(255,255,255,0.18);
      pointer-events: none;
    }
    .hidden { display: none; }

    /* küçük: tek kolon */
    @media (max-width: 980px) {
      #aquarium-wrapper { grid-template-columns: 1fr; height: 82vh; }
      #sidepanel { display: none; }
    }
  </style>
</head>

<body>
  <div id="aquarium-wrapper">
    <!-- SOL: SAHNE -->
    <div id="scene">
      <canvas id="aquariumCanvas"></canvas>
      <div id="sand"></div>
      <div id="aquarium-timer">Süre: 00:00</div>
    </div>

    <!-- SAĞ: ZEN PANEL (sürekli açık) -->
    <aside id="sidepanel">
      <div class="tabbar">
        <button id="tabStats" class="tabbtn active" onclick="setTab('stats')">Durum</button>
        <button id="tabMarket" class="tabbtn" onclick="setTab('market')">Market</button>
      </div>

      <section id="panelStats" class="panel">
        <h2>Zen Durum</h2>
        <div class="kv">
          <div class="muted">Bütçe</div><div id="moneyText" class="mono text-yellow-300">0 ₺</div>
          <div class="muted">Sıcaklık</div><div id="tempText">24.0°C</div>
          <div class="muted">Temizlik</div><div id="cleanText">100%</div>
          <div class="muted">Canlı</div><div id="fishCountText">6</div>
          <div class="muted">Yem</div><div id="foodCountText">0</div>
          <div class="muted">Dışkı</div><div id="poopCountText">0</div>
        </div>

        <div style="margin-top:12px;">
          <label class="block text-xs uppercase mb-1 opacity-70">Sıcaklık Ayarı (Isıtıcı ile)</label>
          <input type="range" id="tempSlider" min="15" max="35" value="24" disabled />
        </div>

        <div class="btnrow">
          <button class="btn primary" onclick="addFood()">Yem At (2₺)</button>
          <button class="btn teal" onclick="cleanTank()">Temizle</button>
        </div>

        <button class="btn danger" style="margin-top:10px; width:100%;" onclick="resetGame()">Akvaryumu Sıfırla</button>

        <div class="muted" style="font-size:0.78rem; margin-top:10px; line-height:1.35;">
          Zen modu: ilgi istemez. Ara ara yem at, bazen temizle; gerisi kendi haline akar.
        </div>
      </section>

      <section id="panelMarket" class="panel" style="display:none;">
        <h2>Market</h2>

        <button onclick="buyItem('filter')" id="buyFilter" class="shopbtn">
          <div class="text-sm font-semibold">Otomatik Filtre</div>
          <div class="text-xs text-yellow-300">500 ₺</div>
          <div class="text-xs muted" style="margin-top:4px;">Temizlik düşüşünü yumuşatır + hafif toparlar.</div>
        </button>

        <div style="height:10px;"></div>

        <button onclick="buyItem('heater')" id="buyHeater" class="shopbtn">
          <div class="text-sm font-semibold">Termostatlı Isıtıcı</div>
          <div class="text-xs text-yellow-300">300 ₺</div>
          <div class="text-xs muted" style="margin-top:4px;">Sıcaklığı hedefe yaklaştırır.</div>
        </button>

        <div style="height:10px;"></div>

        <button onclick="buyItem('plant')" id="buyPlant" class="shopbtn">
          <div class="text-sm font-semibold">Yapay Bitki</div>
          <div class="text-xs text-yellow-300">100 ₺</div>
          <div class="text-xs muted" style="margin-top:4px;">Sadece görsel (şimdilik).</div>
        </button>

        <div class="muted" style="font-size:0.78rem; margin-top:10px; line-height:1.35;">
          İleride “tür” ve “fenotip” paketleri buraya bağlanabilir.
        </div>
      </section>
    </aside>
  </div>

  <div id="notif" class="notification hidden"></div>

<script>
  // =========================
  // DOM
  // =========================
  const wrapper = document.getElementById("aquarium-wrapper");
  const scene = document.getElementById("scene");
  const canvas = document.getElementById("aquariumCanvas");
  const ctx = canvas.getContext("2d");

  // =========================
  // SIM PARAMS
  // =========================
  const MATURITY_TIME = 10 * 60 * 1000;
  const MAX_LIFE = 25 * 60 * 1000;
  const PREGNANCY_TIME = 5 * 60 * 1000;

  // Dışkı sistemi
  const POOP_DELAY_MIN = 12 * 1000;
  const POOP_DELAY_MAX = 28 * 1000;
  const POOP_DIRT_IMPACT = 0.45;   // bir dışkı temizlikten ne kadar götürür
  const EAT_DIRT_IMPACT = 0.08;    // her yem yeme anı küçük kirlilik

  // Zenginleşme / ekonomi
  const MONEY_PER_CREATURE_PER_SEC = 0.007;

  // =========================
  // STATE MODIFIERS
  // =========================
  const STATE_MODS = {
    hunger: {
      fed:    { move: 1.00, metabolism: 1.00, fertility: 1.00, deathRisk: 0.0 },
      hungry: { move: 0.95, metabolism: 1.10, fertility: 0.55, deathRisk: 0.00005 },
      starv:  { move: 0.80, metabolism: 1.35, fertility: 0.00, deathRisk: 0.00040 }
    },
    age: {
      baby:  { move: 1.10, metabolism: 1.20, fertility: 0.00, deathRisk: 0.00001 },
      adult: { move: 1.00, metabolism: 1.00, fertility: 1.00, deathRisk: 0.00002 },
      old:   { move: 0.85, metabolism: 0.92, fertility: 0.30, deathRisk: 0.00010 }
    },
    preg: {
      no:  { move: 1.00, metabolism: 1.00 },
      yes: { move: 0.88, metabolism: 1.18 }
    },
    trait: {
      slow:   { move: 0.86, metabolism: 0.86 },
      normal: { move: 1.00, metabolism: 1.00 },
      fast:   { move: 1.22, metabolism: 1.18 }
    }
  };

  // =========================
  // GLOBAL STATE
  // =========================
  let state = {
    money: 100,
    temp: 24,
    targetTemp: 24,
    cleanliness: 100,
    creatures: [],
    foods: [],
    poops: [],
    plants: [],
    items: { filter: false, heater: false },
    lastTick: performance.now(),
    startTime: Date.now()
  };

  // =========================
  // ENV MODS
  // =========================
  function envMods(temp, cleanliness) {
    const dt = Math.abs(temp - 24);
    const tempStress = Math.max(0, (dt - 4) / 10);
    const dirtStress = Math.max(0, (60 - cleanliness) / 60);

    return {
      move: 1 - (0.20 * tempStress) - (0.15 * dirtStress),
      metabolism: 1 + (0.20 * tempStress) + (0.10 * dirtStress),
      fertility: 1 - (0.55 * dirtStress),
      deathRisk: (0.00005 * dirtStress) + (0.00004 * tempStress)
    };
  }

  function computeDerived(creature) {
    const hState = creature.energy > 70 ? "fed" : (creature.energy > 30 ? "hungry" : "starv");
    const ageState = (Date.now() - creature.bornTime) < MATURITY_TIME ? "baby" : "adult";
    const pState = creature.isPregnant ? "yes" : "no";

    const mods = [
      STATE_MODS.hunger[hState],
      STATE_MODS.age[ageState],
      STATE_MODS.preg[pState],
      STATE_MODS.trait[creature.trait],
      envMods(state.temp, state.cleanliness)
    ];

    const out = { move: 1, metabolism: 1, fertility: 1, deathRisk: 0 };
    mods.forEach(m => {
      if (m.move) out.move *= m.move;
      if (m.metabolism) out.metabolism *= m.metabolism;
      if (m.fertility) out.fertility *= m.fertility;
      if (m.deathRisk) out.deathRisk += m.deathRisk;
    });

    out.move = Math.max(0.45, Math.min(2.1, out.move));
    return { ...out, hState };
  }

  // =========================
  // UTILS
  // =========================
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rand(a, b) { return a + Math.random() * (b - a); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  function showNotification(t) {
    const n = document.getElementById("notif");
    n.innerText = t;
    n.classList.remove("hidden");
    setTimeout(() => n.classList.add("hidden"), 2600);
  }

  function formatTime(ms) {
    const s = Math.floor(ms / 1000);
    return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
  }

  // Fenotip: tek sayı (0..1) → renk tonunu etkiler, eşleşme uyumu da buradan
  function phenotypeToColor(p) {
    // 0..1 => mavi(210) ile pembe(330) arasında gezin
    const hue = lerp(210, 330, p);
    return `hsl(${hue} 85% 70%)`;
  }

  // =========================
  // CREATURE
  // =========================
  class Creature {
    constructor(x, y, gender, opts = {}) {
      this.id = Math.random().toString(36).slice(2, 10);

      this.x = (x ?? (50 + Math.random() * (canvas.width - 100)));
      this.y = (y ?? (50 + Math.random() * (canvas.height - 150)));

      this.gender = gender ?? (Math.random() > 0.5 ? "M" : "F");
      this.trait = opts.trait ?? ["slow", "normal", "fast"][Math.floor(Math.random() * 3)];

      // fenotip (0..1)
      this.pheno = clamp(opts.pheno ?? Math.random(), 0, 1);
      this.color = phenotypeToColor(this.pheno);

      this.vx = (Math.random() - 0.5) * 2.8;
      this.vy = (Math.random() - 0.5) * 2.8;

      this.bornTime = Date.now();
      this.lifeSpan = 15 * 60 * 1000 + Math.random() * (10 * 60 * 1000);

      // Başlangıç enerji: yavrular “tok” başlar (100). Zamanla düşer.
      this.energy = 100;

      this.size = 2;
      this.isPregnant = false;
      this.lastBreedAttempt = 0;
      this.pregnancyStartTime = 0;

      // Movement memory (yön tutarlılığı için)
      this.heading = Math.random() * Math.PI * 2;
      this.wanderAngle = (Math.random() - 0.5) * 0.8;

      // dışkı takvimi
      this.nextPoopAt = Date.now() + rand(POOP_DELAY_MIN, POOP_DELAY_MAX);
    }

    // Arrival steering: hedefe yaklaşırken yavaşlar (dt normalize)
    applyArrivalSteering(tx, ty, maxSpeed, maxForce, dtSec) {
      const dx = tx - this.x;
      const dy = ty - this.y;
      const dist = Math.hypot(dx, dy) || 1e-6;

      const slowRadius = 140;
      const desiredSpeed = dist < slowRadius ? maxSpeed * (dist / slowRadius) : maxSpeed;

      const desiredVx = (dx / dist) * desiredSpeed;
      const desiredVy = (dy / dist) * desiredSpeed;

      let sx = desiredVx - this.vx;
      let sy = desiredVy - this.vy;

      const sm = Math.hypot(sx, sy) || 1e-6;
      const normalizedForce = maxForce * dtSec * 60; // 60fps bazlı

      if (sm > normalizedForce) {
        sx = (sx / sm) * normalizedForce;
        sy = (sy / sm) * normalizedForce;
      }

      this.vx += sx;
      this.vy += sy;
    }

    // Wander steering: organik ama yön tutarlı gezinti
    applyWanderSteering(d, dtSec) {
      const speed = Math.hypot(this.vx, this.vy);

      // heading güncelle
      if (speed > 0.05) this.heading = Math.atan2(this.vy, this.vx);

      // tokken daha gezer, açken daha az
      const wanderStrength = (d.hState === "fed" ? 0.10 : 0.05) * d.move;
      const jitter = (d.hState === "fed" ? 0.9 : 0.55) * dtSec * 60;

      this.wanderAngle += (Math.random() - 0.5) * 0.25 * jitter;
      this.wanderAngle = clamp(this.wanderAngle, -1.2, 1.2);

      const forwardDist = 75;
      const circleRadius = 30;

      const fx = Math.cos(this.heading) * forwardDist;
      const fy = Math.sin(this.heading) * forwardDist;

      const wx = fx + Math.cos(this.heading + this.wanderAngle) * circleRadius;
      const wy = fy + Math.sin(this.heading + this.wanderAngle) * circleRadius;

      const targetX = this.x + wx;
      const targetY = this.y + wy;

      const minCruise = 0.35 * d.move;
      const maxSpeed = Math.max(minCruise, (d.hState === "fed" ? 1.35 : 1.05) * d.move);
      const maxForce = wanderStrength;

      this.applyArrivalSteering(targetX, targetY, maxSpeed, maxForce, dtSec);

      // çok düşerse takılı kalmasın
      const sp = Math.hypot(this.vx, this.vy);
      if (sp < 0.08) {
        const nudge = 0.12 * d.move;
        this.vx += Math.cos(this.heading) * nudge;
        this.vy += Math.sin(this.heading) * nudge;
      }
    }

    update(dtMs) {
      const now = Date.now();
      const age = now - this.bornTime;
      const d = computeDerived(this);
      const dtSec = dtMs / 1000;

      // ölüm olasılığı (saniye bazlı)
      const survivalProb = Math.exp(-d.deathRisk * dtSec);
      if (age > this.lifeSpan || Math.random() > survivalProb) {
        if (age > this.lifeSpan) showNotification("Bir canlı ömrünü tamamladı.");
        return false;
      }

      // enerji tüketimi
      const speedMag = Math.hypot(this.vx, this.vy);
      this.energy -= (0.012 + (speedMag * 0.006)) * d.metabolism * dtSec;
      this.energy = Math.max(0, this.energy);

      // büyüme
      if (age < MATURITY_TIME) {
        this.size = 2 + (age / MATURITY_TIME) * 8;
      } else {
        this.size = 10 + ((age - MATURITY_TIME) / (MAX_LIFE - MATURITY_TIME)) * 5;
      }

      // damping (fps normalize + daha canlı)
      const damp = Math.pow(0.994, dtSec * 60);  // 0.992-0.996 arası oynayabilirsin
      this.vx *= damp;
      this.vy *= damp;

      // yemek hedefleme (aç değilse hiç uğraşma)
      const ate = this.findFood(d, dtSec);

      // eğer yem kovalamıyorsa -> wander
      if (!ate) {
        this.applyWanderSteering(d, dtSec);
      }

      // hız limiti
      const currentSpeed = Math.hypot(this.vx, this.vy);
      const maxAllowed = (d.hState === "starv" ? 2.7 : (d.hState === "hungry" ? 2.2 : 1.9)) * d.move;
      if (currentSpeed > maxAllowed) {
        this.vx = (this.vx / currentSpeed) * maxAllowed;
        this.vy = (this.vy / currentSpeed) * maxAllowed;
      }

      // hareket uygula
      this.x += this.vx;
      this.y += this.vy;

      // sınırlar
      const left = 15, right = canvas.width - 15;
      const top = 15, bottom = canvas.height - 60;

      if (this.x < left)  { this.x = left;  this.vx = Math.abs(this.vx); }
      if (this.x > right) { this.x = right; this.vx = -Math.abs(this.vx); }
      if (this.y < top)   { this.y = top;   this.vy = Math.abs(this.vy); }
      if (this.y > bottom){ this.y = bottom;this.vy = -Math.abs(this.vy); }

      // doğum
      if (this.isPregnant && now - this.pregnancyStartTime > PREGNANCY_TIME) {
        this.giveBirth();
      }

      // dışkılama
      if (now >= this.nextPoopAt) {
        this.poop();
        this.nextPoopAt = now + rand(POOP_DELAY_MIN, POOP_DELAY_MAX);
      }

      return true;
    }

    // Tok balık yem kovalamaz: fed => return false (hedef yok)
    findFood(d, dtSec) {
      if (d.hState === "fed") return false;
      if (state.foods.length === 0) return false;

      const visionRange = (d.hState === "starv" ? 650 : 340);
      let nearest = null;
      let minDist = Infinity;

      for (const f of state.foods) {
        const dist = Math.hypot(f.x - this.x, f.y - this.y);
        if (dist < visionRange && dist < minDist) { minDist = dist; nearest = f; }
      }
      if (!nearest) return false;

      const maxSpeed = (d.hState === "starv" ? 2.4 : 1.8) * d.move;
      const maxForce = (d.hState === "starv" ? 0.18 : 0.12);

      this.applyArrivalSteering(nearest.x, nearest.y, maxSpeed, maxForce, dtSec);

      // yeme
      if (minDist < this.size + 10) {
        state.foods = state.foods.filter(x => x !== nearest);
        this.energy = Math.min(100, this.energy + 38);

        // “yeme anı” freni (spiral/dönme azaltır)
        this.vx *= 0.65;
        this.vy *= 0.65;

        // kirlilik
        state.cleanliness = clamp(state.cleanliness - EAT_DIRT_IMPACT, 0, 100);

        // dışkı biraz daha yakınlaşsın (yem yediyse)
        this.nextPoopAt = Math.min(this.nextPoopAt, Date.now() + rand(POOP_DELAY_MIN * 0.6, POOP_DELAY_MAX * 0.7));
      }

      return true;
    }

    poop() {
      // dışkı parçacığı
      state.poops.push({
        x: this.x + rand(-6, 6),
        y: this.y + rand(4, 10),
        vy: rand(0.35, 0.65),
        born: Date.now()
      });

      // temizlik düşüşü (filter varsa hafifler)
      const impact = state.items.filter ? (POOP_DIRT_IMPACT * 0.55) : POOP_DIRT_IMPACT;
      state.cleanliness = clamp(state.cleanliness - impact, 0, 100);
    }

    draw() {
      const d = computeDerived(this);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.globalAlpha = (d.hState === "starv" ? 0.65 : 1.0);

      // gövde
      ctx.fillStyle = this.color;

      if (this.size < 6) {
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.rotate(Math.atan2(this.vy, this.vx));

        // gövde
        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size / 1.65, 0, 0, Math.PI * 2);
        ctx.fill();

        // kuyruk
        ctx.beginPath();
        ctx.moveTo(-this.size, 0);
        ctx.lineTo(-this.size - 6, -5);
        ctx.lineTo(-this.size - 6, 5);
        ctx.closePath();
        ctx.fill();

        // hamilelik işareti
        if (this.isPregnant) {
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          ctx.beginPath();
          ctx.arc(0, 2, this.size / 3.2, 0, Math.PI * 2);
          ctx.fill();
        }

        // küçük “fenotip noktası”
        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath();
        ctx.arc(this.size * 0.35, -this.size * 0.10, 1.7, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    giveBirth() {
      this.isPregnant = false;

      // yavru genleri: anne fenotipi + küçük mutasyon
      const babyPheno = clamp(this.pheno + (Math.random() - 0.5) * 0.12, 0, 1);
      const babyTrait = (Math.random() < 0.72) ? this.trait : ["slow","normal","fast"][Math.floor(Math.random()*3)];

      state.creatures.push(new Creature(this.x, this.y, undefined, { pheno: babyPheno, trait: babyTrait }));
      showNotification("Yeni bir yavru doğdu!");
    }
  }

  // =========================
  // UI: Tabs
  // =========================
  function setTab(which) {
    const stats = document.getElementById("panelStats");
    const market = document.getElementById("panelMarket");
    const t1 = document.getElementById("tabStats");
    const t2 = document.getElementById("tabMarket");

    if (which === "stats") {
      stats.style.display = "block";
      market.style.display = "none";
      t1.classList.add("active");
      t2.classList.remove("active");
    } else {
      stats.style.display = "none";
      market.style.display = "block";
      t2.classList.add("active");
      t1.classList.remove("active");
    }
  }

  // =========================
  // RESIZE / INIT
  // =========================
  function resize() {
    // canvas sadece sol kolonu kaplasın
    canvas.width = scene.clientWidth;
    canvas.height = scene.clientHeight;
  }
  window.addEventListener("resize", resize);

  function createBubble() {
    const b = document.createElement("div");
    b.className = "bubble";
    const size = Math.random() * 8 + 2;
    b.style.width = size + "px";
    b.style.height = size + "px";
    b.style.left = Math.random() * 100 + "%";
    b.style.animationDuration = (Math.random() * 4 + 6) + "s";
    scene.appendChild(b);
  }

  function init() {
    resize();

    state.creatures = [];
    state.foods = [];
    state.poops = [];
    state.plants = [];

    state.startTime = Date.now();
    state.lastTick = performance.now();

    // başlangıç popülasyon
    for (let i = 0; i < 3; i++) state.creatures.push(new Creature(null, null, "M"));
    for (let i = 0; i < 3; i++) state.creatures.push(new Creature(null, null, "F"));

    // baloncuklar
    for (let i = 0; i < 16; i++) createBubble();

    showNotification("Zen Akvaryum hazır.");
  }

  // =========================
  // ACTIONS
  // =========================
  function addFood() {
    if (state.money < 2) return showNotification("Yeterli para yok!");
    state.money -= 2;

    for (let i = 0; i < 6; i++) {
      state.foods.push({
        x: 40 + Math.random() * (canvas.width - 80),
        y: 0,
        vy: 0.65 + Math.random() * 0.35
      });
    }
  }

  function cleanTank() {
    state.cleanliness = Math.min(100, state.cleanliness + 30);
    showNotification("Akvaryum temizlendi!");
  }

  function buyItem(type) {
    const prices = { filter: 500, heater: 300, plant: 100 };

    if (state.money < prices[type]) return showNotification("Bütçe yetmiyor!");
    state.money -= prices[type];

    if (type === "plant") {
      state.plants.push({ x: 50 + Math.random() * (canvas.width - 100), h: 40 + Math.random() * 60 });
    } else {
      state.items[type] = true;
      const btn = document.getElementById("buy" + type.charAt(0).toUpperCase() + type.slice(1));
      if (btn) btn.disabled = true;

      if (type === "heater") {
        document.getElementById("tempSlider").disabled = false;
      }
    }
    showNotification("Eşya alındı!");
  }

  function resetGame() {
    location.reload();
  }

  // =========================
  // MAIN LOOP: LOGIC
  // =========================
  function updateLogic(dtMs) {
    const now = Date.now();
    const dtSec = dtMs / 1000;

    // çevre: sıcaklık
    if (state.items.heater) {
      const target = state.targetTemp;
      state.temp += (target - state.temp) * (0.018 * dtSec * 60); // normalize
    } else {
      state.temp += (20 - state.temp) * (0.0012 * dtSec * 60);
    }

    // filtre varsa hedef ısı sliderdan alınır
    if (state.items.heater) state.targetTemp = parseInt(document.getElementById("tempSlider").value, 10);

    // temizlik: temel düşüş (pop + yem + dışkı zaten ayrıca ekliyor)
    let basePollution = (state.creatures.length * 0.00055) * (dtSec * 60);
    if (state.items.filter) {
      basePollution *= 0.35;
      if (state.cleanliness < 82) state.cleanliness += 0.020 * (dtSec * 60);
    }
    state.cleanliness = clamp(state.cleanliness - basePollution, 0, 100);

    // ekonomi: temizlik iyi + sıcaklık iyi => para
    if (state.cleanliness > 60 && Math.abs(state.temp - 24) < 5) {
      state.money += (state.creatures.length * MONEY_PER_CREATURE_PER_SEC) * (dtSec * 60);
    }

    // yem hareketi (düşüş)
    for (const f of state.foods) {
      f.y += f.vy * (dtSec * 60);
      if (f.y > canvas.height - 62) f.y = canvas.height - 62;
    }

    // dışkı hareketi + yaşlanma (fazla birikmesin)
    state.poops = state.poops.filter(p => (now - p.born) < 90 * 1000);
    for (const p of state.poops) {
      p.y += p.vy * (dtSec * 60);
      if (p.y > canvas.height - 62) p.y = canvas.height - 62;
    }

    // canlılar
    state.creatures = state.creatures.filter(c => c.update(dtMs));

    // üreme: fenotip uyumu (benzerlik) üremeyi etkiler (zen/evrim tadı)
    const females = state.creatures.filter(c =>
      c.gender === "F" && (now - c.bornTime) > MATURITY_TIME && !c.isPregnant && c.energy > 45
    );
    const males = state.creatures.filter(c =>
      c.gender === "M" && (now - c.bornTime) > MATURITY_TIME && c.energy > 45
    );

    for (const f of females) {
      for (const m of males) {
        // yakınlık şartı
        if (Math.hypot(f.x - m.x, f.y - m.y) >= 44) continue;
        if (now - f.lastBreedAttempt <= 20000) continue;

        f.lastBreedAttempt = now;

        const df = computeDerived(f);
        const env = envMods(state.temp, state.cleanliness);

        // fenotip uyumu: 0..1 (yakınsa 1)
        const compat = 1 - Math.abs(f.pheno - m.pheno); // 0..1
        // uyum üremeyi arttırsın, ama environment ve df.fertility ile çarpılsın
        const chance = 0.12 * df.fertility * env.fertility * (0.55 + 0.85 * compat);

        if (Math.random() < chance) {
          f.isPregnant = true;
          f.pregnancyStartTime = now;

          // yavru genleri (babadan da etki): anne doğuruyor, ama gen karışsın
          const mix = (f.pheno + m.pheno) / 2;
          f.pheno = clamp(f.pheno, 0, 1); // güvenlik
          // doğacak bebeğe babayı da katmak için: hamilelikte anneye “pending genes”
          f._babyPheno = clamp(mix + (Math.random() - 0.5) * 0.08, 0, 1);
          f._babyTrait = (Math.random() < 0.6) ? f.trait : m.trait;
        }
      }
    }

    // UI
    document.getElementById("moneyText").innerText = Math.floor(state.money) + " ₺";
    document.getElementById("tempText").innerText = state.temp.toFixed(1) + "°C";
    document.getElementById("cleanText").innerText = Math.floor(state.cleanliness) + "%";
    document.getElementById("fishCountText").innerText = state.creatures.length;
    document.getElementById("foodCountText").innerText = state.foods.length;
    document.getElementById("poopCountText").innerText = state.poops.length;
    document.getElementById("aquarium-timer").innerText = "Süre: " + formatTime(now - state.startTime);
  }

  // Creature.giveBirth override: babadan gelen genleri kullanmak için küçük patch
  const _origGiveBirth = Creature.prototype.giveBirth;
  Creature.prototype.giveBirth = function() {
    const babyPheno = clamp((this._babyPheno ?? this.pheno) + (Math.random() - 0.5) * 0.06, 0, 1);
    const babyTrait = this._babyTrait ?? this.trait;

    this.isPregnant = false;
    this._babyPheno = undefined;
    this._babyTrait = undefined;

    state.creatures.push(new Creature(this.x, this.y, undefined, { pheno: babyPheno, trait: babyTrait }));
    showNotification("Yeni bir yavru doğdu!");
  };

  // =========================
  // RENDER LOOP
  // =========================
  function draw(ts) {
    const dtMs = Math.min(50, ts - state.lastTick);
    state.lastTick = ts;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // bitkiler
    for (const p of state.plants) {
      ctx.fillStyle = "#166534";
      ctx.beginPath();
      ctx.moveTo(p.x, canvas.height - 60);
      ctx.quadraticCurveTo(p.x + 10, canvas.height - 60 - p.h/2, p.x, canvas.height - 60 - p.h);
      ctx.quadraticCurveTo(p.x - 10, canvas.height - 60 - p.h/2, p.x, canvas.height - 60);
      ctx.fill();
    }

    // yemler
    ctx.fillStyle = "#fbbf24";
    for (const f of state.foods) {
      ctx.beginPath();
      ctx.arc(f.x, f.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    }

    // dışkılar
    ctx.fillStyle = "rgba(15,23,42,0.6)";
    for (const p of state.poops) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    // canlılar
    for (const c of state.creatures) c.draw();

    updateLogic(dtMs);
    requestAnimationFrame(draw);
  }

  // boot
  window.onload = init;
  requestAnimationFrame(draw);
</script>
</body>
</html>
