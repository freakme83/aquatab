<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zen Akvaryum: State & Trait Sim</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: #020617;
      color: #f8fafc;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    #aquarium-wrapper {
      position: relative;
      width: 92vw;
      max-width: 1200px;
      height: 72vh;
      background: linear-gradient(180deg, #1e40af 0%, #1e3a8a 100%);
      border: 8px solid #334155;
      border-radius: 20px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      display: grid;
      grid-template-columns: 1fr 320px;
    }

    #scene { position: relative; overflow: hidden; }
    canvas { display: block; }

    #sand {
      position: absolute;
      bottom: 0; left: 0;
      width: 100%;
      height: 60px;
      background: #ca8a04;
      border-top: 4px solid #a16207;
      z-index: 10;
      pointer-events: none;
    }

    #aquarium-timer {
      position: absolute;
      bottom: 70px;
      right: 14px;
      z-index: 50;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.35);
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 0.78rem;
      color: rgba(255, 255, 255, 0.75);
      border: 1px solid rgba(255, 255, 255, 0.12);
      pointer-events: none;
    }

    #sidepanel {
      border-left: 1px solid rgba(255,255,255,0.12);
      background: rgba(15, 23, 42, 0.92);
      backdrop-filter: blur(10px);
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .tabbar { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .tabbtn {
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(30, 41, 59, 0.55);
      padding: 10px 10px;
      border-radius: 12px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.12s ease, background 0.12s ease;
    }
    .tabbtn:hover { transform: translateY(-1px); background: rgba(30, 41, 59, 0.75); }
    .tabbtn.active { background: rgba(59, 130, 246, 0.28); border-color: rgba(59,130,246,0.5); }

    .panel {
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 12px;
      background: rgba(2,6,23,0.25);
    }
    .panel h2 { margin: 0 0 10px 0; font-size: 1.05rem; font-weight: 800; }
    .kv { display: grid; grid-template-columns: 1fr auto; gap: 6px 10px; font-size: 0.86rem; }
    .muted { opacity: 0.75; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .btnrow { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
    .btn {
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(30,41,59,0.55);
      border-radius: 12px;
      padding: 10px;
      font-size: 0.86rem;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.12s ease;
    }
    .btn:hover { background: rgba(30,41,59,0.75); transform: translateY(-1px); }
    .btn.primary { background: rgba(37,99,235,0.65); border-color: rgba(37,99,235,0.55); }
    .btn.primary:hover { background: rgba(37,99,235,0.78); }
    .btn.teal { background: rgba(13,148,136,0.6); border-color: rgba(13,148,136,0.55); }
    .btn.teal:hover { background: rgba(13,148,136,0.75); }
    .btn.danger { background: rgba(127,29,29,0.35); border-color: rgba(185,28,28,0.35); }
    .btn.danger:hover { background: rgba(127,29,29,0.5); }

    input[type="range"] { width: 100%; }

    .shopbtn {
      width: 100%;
      text-align: left;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(30,41,59,0.35);
      border-radius: 14px;
      padding: 12px;
      cursor: pointer;
      transition: background 0.12s ease, transform 0.12s ease;
    }
    .shopbtn:hover { background: rgba(30,41,59,0.55); transform: translateY(-1px); }
    .shopbtn:disabled { opacity: 0.35; cursor: not-allowed; transform: none; }

    .bubble {
      position: absolute;
      background: rgba(255, 255, 255, 0.20);
      border-radius: 50%;
      pointer-events: none;
      animation: rise 8s linear infinite;
      z-index: 2;
    }
    @keyframes rise {
      0% { transform: translateY(120%) scale(1); opacity: 0; }
      50% { opacity: 0.35; }
      100% { transform: translateY(-220px) scale(1.5); opacity: 0; }
    }

    .notification {
      position: fixed;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.92);
      padding: 8px 14px;
      border-radius: 999px;
      z-index: 1000;
      font-size: 0.82rem;
      border: 1px solid rgba(255,255,255,0.18);
      pointer-events: none;
    }
    .hidden { display: none; }

    @media (max-width: 980px) {
      #aquarium-wrapper { grid-template-columns: 1fr; height: 82vh; }
      #sidepanel { display: none; }
    }
  </style>
</head>

<body>
  <div id="aquarium-wrapper">
    <div id="scene">
      <canvas id="aquariumCanvas"></canvas>
      <div id="sand"></div>
      <div id="aquarium-timer">Süre: 00:00</div>
    </div>

    <aside id="sidepanel">
      <div class="tabbar">
        <button id="tabStats" class="tabbtn active" onclick="setTab('stats')">Durum</button>
        <button id="tabMarket" class="tabbtn" onclick="setTab('market')">Market</button>
      </div>

      <section id="panelStats" class="panel">
        <h2>Zen Durum</h2>
        <div class="kv">
          <div class="muted">Bütçe</div><div id="moneyText" class="mono text-yellow-300">0 ₺</div>
          <div class="muted">Sıcaklık</div><div id="tempText">24.0°C</div>
          <div class="muted">Temizlik</div><div id="cleanText">100%</div>
          <div class="muted">Canlı</div><div id="fishCountText">6</div>
          <div class="muted">Yem</div><div id="foodCountText">0</div>
          <div class="muted">Dışkı</div><div id="poopCountText">0</div>
        </div>

        <div style="margin-top:12px;">
          <label class="block text-xs uppercase mb-1 opacity-70">Sıcaklık Ayarı (Isıtıcı ile)</label>
          <input type="range" id="tempSlider" min="15" max="35" value="24" disabled />
        </div>

        <div class="btnrow">
          <button class="btn primary" onclick="addFood()">Yem At (2₺)</button>
          <button class="btn teal" onclick="cleanTank()">Temizle</button>
        </div>

        <button class="btn danger" style="margin-top:10px; width:100%;" onclick="resetGame()">Akvaryumu Sıfırla</button>

        <div class="muted" style="font-size:0.78rem; margin-top:10px; line-height:1.35;">
          Zen modu: ilgi istemez. Ara ara yem at, bazen temizle; gerisi kendi haline akar.
        </div>
      </section>

      <section id="panelMarket" class="panel" style="display:none;">
        <h2>Market</h2>

        <button onclick="buyItem('filter')" id="buyFilter" class="shopbtn">
          <div class="text-sm font-semibold">Otomatik Filtre</div>
          <div class="text-xs text-yellow-300">500 ₺</div>
          <div class="text-xs muted" style="margin-top:4px;">Temizlik düşüşünü yumuşatır + hafif toparlar.</div>
        </button>

        <div style="height:10px;"></div>

        <button onclick="buyItem('heater')" id="buyHeater" class="shopbtn">
          <div class="text-sm font-semibold">Termostatlı Isıtıcı</div>
          <div class="text-xs text-yellow-300">300 ₺</div>
          <div class="text-xs muted" style="margin-top:4px;">Sıcaklığı hedefe yaklaştırır.</div>
        </button>

        <div style="height:10px;"></div>

        <button onclick="buyItem('plant')" id="buyPlant" class="shopbtn">
          <div class="text-sm font-semibold">Yapay Bitki</div>
          <div class="text-xs text-yellow-300">100 ₺</div>
          <div class="text-xs muted" style="margin-top:4px;">Sadece görsel (şimdilik).</div>
        </button>

        <div class="muted" style="font-size:0.78rem; margin-top:10px; line-height:1.35;">
          İleride “tür” ve “fenotip” paketleri buraya bağlanabilir.
        </div>
      </section>
    </aside>
  </div>

  <div id="notif" class="notification hidden"></div>

<script>
  const scene = document.getElementById("scene");
  const canvas = document.getElementById("aquariumCanvas");
  const ctx = canvas.getContext("2d");

  const MATURITY_TIME = 10 * 60 * 1000;
  const MAX_LIFE = 25 * 60 * 1000;
  const PREGNANCY_TIME = 5 * 60 * 1000;

  const POOP_DELAY_MIN = 12 * 1000;
  const POOP_DELAY_MAX = 28 * 1000;
  const POOP_DIRT_IMPACT = 0.45;
  const EAT_DIRT_IMPACT = 0.08;

  const MONEY_PER_CREATURE_PER_SEC = 0.007;

  const STATE_MODS = {
    hunger: {
      fed:    { move: 1.00, metabolism: 1.00, fertility: 1.00, deathRisk: 0.0 },
      hungry: { move: 0.95, metabolism: 1.10, fertility: 0.55, deathRisk: 0.00005 },
      starv:  { move: 0.80, metabolism: 1.35, fertility: 0.00, deathRisk: 0.00040 }
    },
    age: {
      baby:  { move: 1.10, metabolism: 1.20, fertility: 0.00, deathRisk: 0.00001 },
      adult: { move: 1.00, metabolism: 1.00, fertility: 1.00, deathRisk: 0.00002 },
      old:   { move: 0.85, metabolism: 0.92, fertility: 0.30, deathRisk: 0.00010 }
    },
    preg: {
      no:  { move: 1.00, metabolism: 1.00 },
      yes: { move: 0.88, metabolism: 1.18 }
    },
    trait: {
      slow:   { move: 0.86, metabolism: 0.86 },
      normal: { move: 1.00, metabolism: 1.00 },
      fast:   { move: 1.22, metabolism: 1.18 }
    }
  };

  let state = {
    money: 100,
    temp: 24,
    targetTemp: 24,
    cleanliness: 100,
    creatures: [],
    foods: [],
    poops: [],
    plants: [],
    items: { filter: false, heater: false },
    lastTick: performance.now(),
    startTime: Date.now()
  };

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function rand(a, b) { return a + Math.random() * (b - a); }
  function lerp(a, b, t) { return a + (b - a) * t; }

  function showNotification(t) {
    const n = document.getElementById("notif");
    n.innerText = t;
    n.classList.remove("hidden");
    setTimeout(() => n.classList.add("hidden"), 2600);
  }

  function formatTime(ms) {
    const s = Math.floor(ms / 1000);
    return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
  }

  function envMods(temp, cleanliness) {
    const dt = Math.abs(temp - 24);
    const tempStress = Math.max(0, (dt - 4) / 10);
    const dirtStress = Math.max(0, (60 - cleanliness) / 60);

    return {
      move: 1 - (0.20 * tempStress) - (0.15 * dirtStress),
      metabolism: 1 + (0.20 * tempStress) + (0.10 * dirtStress),
      fertility: 1 - (0.55 * dirtStress),
      deathRisk: (0.00005 * dirtStress) + (0.00004 * tempStress)
    };
  }

  function computeDerived(creature) {
    const hState = creature.energy > 70 ? "fed" : (creature.energy > 30 ? "hungry" : "starv");
    const ageState = (Date.now() - creature.bornTime) < MATURITY_TIME ? "baby" : "adult";
    const pState = creature.isPregnant ? "yes" : "no";

    const mods = [
      STATE_MODS.hunger[hState],
      STATE_MODS.age[ageState],
      STATE_MODS.preg[pState],
      STATE_MODS.trait[creature.trait],
      envMods(state.temp, state.cleanliness)
    ];

    const out = { move: 1, metabolism: 1, fertility: 1, deathRisk: 0 };
    mods.forEach(m => {
      if (m.move) out.move *= m.move;
      if (m.metabolism) out.metabolism *= m.metabolism;
      if (m.fertility) out.fertility *= m.fertility;
      if (m.deathRisk) out.deathRisk += m.deathRisk;
    });

    out.move = Math.max(0.45, Math.min(2.1, out.move));
    return { ...out, hState };
  }

  function phenotypeToColor(p) {
    const hue = lerp(210, 330, p);
    return `hsl(${hue} 85% 70%)`;
  }

  function angleDiff(a, b) {
    let d = (b - a + Math.PI) % (Math.PI * 2) - Math.PI;
    if (d < -Math.PI) d += Math.PI * 2;
    return d;
  }
  function moveTowardAngle(a, b, maxStep) {
    const d = angleDiff(a, b);
    if (Math.abs(d) <= maxStep) return b;
    return a + Math.sign(d) * maxStep;
  }

  class Creature {
    constructor(x, y, gender, opts = {}) {
      this.id = Math.random().toString(36).slice(2, 10);

      this.x = (x ?? (50 + Math.random() * (canvas.width - 100)));
      this.y = (y ?? (50 + Math.random() * (canvas.height - 150)));

      this.gender = gender ?? (Math.random() > 0.5 ? "M" : "F");
      this.trait = opts.trait ?? ["slow", "normal", "fast"][Math.floor(Math.random() * 3)];

      this.pheno = clamp(opts.pheno ?? Math.random(), 0, 1);
      this.color = phenotypeToColor(this.pheno);

      this.vx = (Math.random() - 0.5) * 2.2;
      this.vy = (Math.random() - 0.5) * 2.2;

      this.bornTime = Date.now();
      this.lifeSpan = 15 * 60 * 1000 + Math.random() * (10 * 60 * 1000);

      this.energy = 100; // başlangıç tok
      this.size = 2;

      this.isPregnant = false;
      this.lastBreedAttempt = 0;
      this.pregnancyStartTime = 0;

      this.heading = Math.random() * Math.PI * 2;
      this.wanderAngle = (Math.random() - 0.5) * 0.4;

      this.nextPoopAt = Date.now() + rand(POOP_DELAY_MIN, POOP_DELAY_MAX);
    }

    applyArrivalSteering(tx, ty, maxSpeed, maxForce, dtSec) {
      const dx = tx - this.x;
      const dy = ty - this.y;
      const dist = Math.hypot(dx, dy) || 1e-6;

      const slowRadius = 140;
      const desiredSpeed = dist < slowRadius ? maxSpeed * (dist / slowRadius) : maxSpeed;

      const desiredVx = (dx / dist) * desiredSpeed;
      const desiredVy = (dy / dist) * desiredSpeed;

      let sx = desiredVx - this.vx;
      let sy = desiredVy - this.vy;

      const sm = Math.hypot(sx, sy) || 1e-6;
      const normalizedForce = maxForce * dtSec * 60;

      if (sm > normalizedForce) {
        sx = (sx / sm) * normalizedForce;
        sy = (sy / sm) * normalizedForce;
      }

      this.vx += sx;
      this.vy += sy;
    }

    // ✅ YENİ: wander artık "heading" odaklı (spin azaltır)
    applyWanderSteering(d, dtSec) {
      const speed = Math.hypot(this.vx, this.vy);
      if (speed > 0.08) this.heading = Math.atan2(this.vy, this.vx);

      // tokken daha “gezgin”
      const turnRate = (d.hState === "fed" ? 1.1 : 0.7) * dtSec;  // rad/s
      const jitter = (d.hState === "fed" ? 0.55 : 0.35) * dtSec * 60;

      // wanderAngle daha küçük + daha yumuşak
      this.wanderAngle += (Math.random() - 0.5) * 0.10 * jitter;
      this.wanderAngle = clamp(this.wanderAngle, -0.55, 0.55);

      // hedef heading
      const desiredHeading = this.heading + this.wanderAngle;

      // heading’i turn-rate ile yaklaş
      this.heading = moveTowardAngle(this.heading, desiredHeading, turnRate);

      // cruise speed: yeterince akıcı ama deli değil
      const base = (d.hState === "fed" ? 1.25 : 1.00) * d.move;
      const minCruise = 0.45 * d.move;
      const desiredSpeed = Math.max(minCruise, base);

      const ux = Math.cos(this.heading);
      const uy = Math.sin(this.heading);

      const desiredVx = ux * desiredSpeed;
      const desiredVy = uy * desiredSpeed;

      let sx = desiredVx - this.vx;
      let sy = desiredVy - this.vy;

      const maxForce = (d.hState === "fed" ? 0.10 : 0.07) * d.move;
      const sm = Math.hypot(sx, sy) || 1e-6;
      const cap = maxForce * dtSec * 60;

      if (sm > cap) {
        sx = (sx / sm) * cap;
        sy = (sy / sm) * cap;
      }

      this.vx += sx;
      this.vy += sy;

      // ✅ spin kırıcı: velocity’nin heading’e dik bileşenini sönümle
      const dot = this.vx * ux + this.vy * uy;
      const perpX = this.vx - dot * ux;
      const perpY = this.vy - dot * uy;
      const sideDamp = 0.18 * dtSec * 60; // arttırırsan daha “raylı” olur
      this.vx -= perpX * sideDamp;
      this.vy -= perpY * sideDamp;
    }

    findFood(d, dtSec) {
      if (d.hState === "fed") return false;
      if (state.foods.length === 0) return false;

      const visionRange = (d.hState === "starv" ? 650 : 340);
      let nearest = null;
      let minDist = Infinity;

      for (const f of state.foods) {
        const dist = Math.hypot(f.x - this.x, f.y - this.y);
        if (dist < visionRange && dist < minDist) { minDist = dist; nearest = f; }
      }
      if (!nearest) return false;

      const maxSpeed = (d.hState === "starv" ? 2.4 : 1.8) * d.move;
      const maxForce = (d.hState === "starv" ? 0.18 : 0.12);

      this.applyArrivalSteering(nearest.x, nearest.y, maxSpeed, maxForce, dtSec);

      if (minDist < this.size + 10) {
        state.foods = state.foods.filter(x => x !== nearest);
        this.energy = Math.min(100, this.energy + 38);

        this.vx *= 0.65;
        this.vy *= 0.65;

        state.cleanliness = clamp(state.cleanliness - EAT_DIRT_IMPACT, 0, 100);
        this.nextPoopAt = Math.min(this.nextPoopAt, Date.now() + rand(POOP_DELAY_MIN * 0.6, POOP_DELAY_MAX * 0.7));
      }

      return true;
    }

    poop() {
      state.poops.push({
        x: this.x + rand(-6, 6),
        y: this.y + rand(4, 10),
        vy: rand(0.35, 0.65),
        born: Date.now()
      });

      const impact = state.items.filter ? (POOP_DIRT_IMPACT * 0.55) : POOP_DIRT_IMPACT;
      state.cleanliness = clamp(state.cleanliness - impact, 0, 100);
    }

    update(dtMs) {
      const now = Date.now();
      const age = now - this.bornTime;
      const d = computeDerived(this);
      const dtSec = dtMs / 1000;

      const survivalProb = Math.exp(-d.deathRisk * dtSec);
      if (age > this.lifeSpan || Math.random() > survivalProb) {
        if (age > this.lifeSpan) showNotification("Bir canlı ömrünü tamamladı.");
        return false;
      }

      const speedMag = Math.hypot(this.vx, this.vy);
      this.energy -= (0.012 + (speedMag * 0.006)) * d.metabolism * dtSec;
      this.energy = Math.max(0, this.energy);

      if (age < MATURITY_TIME) this.size = 2 + (age / MATURITY_TIME) * 8;
      else this.size = 10 + ((age - MATURITY_TIME) / (MAX_LIFE - MATURITY_TIME)) * 5;

      // damping (bir tık daha az: daha canlı akar)
      const damp = Math.pow(0.996, dtSec * 60);
      this.vx *= damp;
      this.vy *= damp;

      const ate = this.findFood(d, dtSec);
      if (!ate) this.applyWanderSteering(d, dtSec);

      const currentSpeed = Math.hypot(this.vx, this.vy);
      const maxAllowed = (d.hState === "starv" ? 2.7 : (d.hState === "hungry" ? 2.2 : 1.9)) * d.move;
      if (currentSpeed > maxAllowed) {
        this.vx = (this.vx / currentSpeed) * maxAllowed;
        this.vy = (this.vy / currentSpeed) * maxAllowed;
      }

      this.x += this.vx;
      this.y += this.vy;

      const left = 15, right = canvas.width - 15;
      const top = 15, bottom = canvas.height - 60;

      if (this.x < left)  { this.x = left;  this.vx = Math.abs(this.vx); }
      if (this.x > right) { this.x = right; this.vx = -Math.abs(this.vx); }
      if (this.y < top)   { this.y = top;   this.vy = Math.abs(this.vy); }
      if (this.y > bottom){ this.y = bottom;this.vy = -Math.abs(this.vy); }

      if (this.isPregnant && now - this.pregnancyStartTime > PREGNANCY_TIME) this.giveBirth();
      if (now >= this.nextPoopAt) { this.poop(); this.nextPoopAt = now + rand(POOP_DELAY_MIN, POOP_DELAY_MAX); }

      return true;
    }

    draw() {
      const d = computeDerived(this);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.globalAlpha = (d.hState === "starv" ? 0.65 : 1.0);

      ctx.fillStyle = this.color;

      if (this.size < 6) {
        ctx.beginPath();
        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
        ctx.fill();
      } else {
        ctx.rotate(Math.atan2(this.vy, this.vx));

        ctx.beginPath();
        ctx.ellipse(0, 0, this.size, this.size / 1.65, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(-this.size, 0);
        ctx.lineTo(-this.size - 6, -5);
        ctx.lineTo(-this.size - 6, 5);
        ctx.closePath();
        ctx.fill();

        if (this.isPregnant) {
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          ctx.beginPath();
          ctx.arc(0, 2, this.size / 3.2, 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.fillStyle = "rgba(255,255,255,0.25)";
        ctx.beginPath();
        ctx.arc(this.size * 0.35, -this.size * 0.10, 1.7, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.restore();
    }

    giveBirth() {
      const babyPheno = clamp((this._babyPheno ?? this.pheno) + (Math.random() - 0.5) * 0.06, 0, 1);
      const babyTrait = this._babyTrait ?? this.trait;

      this.isPregnant = false;
      this._babyPheno = undefined;
      this._babyTrait = undefined;

      state.creatures.push(new Creature(this.x, this.y, undefined, { pheno: babyPheno, trait: babyTrait }));
      showNotification("Yeni bir yavru doğdu!");
    }
  }

  function setTab(which) {
    const stats = document.getElementById("panelStats");
    const market = document.getElementById("panelMarket");
    const t1 = document.getElementById("tabStats");
    const t2 = document.getElementById("tabMarket");

    if (which === "stats") {
      stats.style.display = "block";
      market.style.display = "none";
      t1.classList.add("active");
      t2.classList.remove("active");
    } else {
      stats.style.display = "none";
      market.style.display = "block";
      t2.classList.add("active");
      t1.classList.remove("active");
    }
  }

  function resize() {
    canvas.width = scene.clientWidth;
    canvas.height = scene.clientHeight;
  }
  window.addEventListener("resize", resize);

  function createBubble() {
    const b = document.createElement("div");
    b.className = "bubble";
    const size = Math.random() * 8 + 2;
    b.style.width = size + "px";
    b.style.height = size + "px";
    b.style.left = Math.random() * 100 + "%";
    b.style.animationDuration = (Math.random() * 4 + 6) + "s";
    scene.appendChild(b);
  }

  function init() {
    resize();

    state.creatures = [];
    state.foods = [];
    state.poops = [];
    state.plants = [];
    state.startTime = Date.now();
    state.lastTick = performance.now();

    for (let i = 0; i < 3; i++) state.creatures.push(new Creature(null, null, "M"));
    for (let i = 0; i < 3; i++) state.creatures.push(new Creature(null, null, "F"));

    for (let i = 0; i < 16; i++) createBubble();

    showNotification("Zen Akvaryum hazır.");
  }

  function addFood() {
    if (state.money < 2) return showNotification("Yeterli para yok!");
    state.money -= 2;

    for (let i = 0; i < 6; i++) {
      state.foods.push({
        x: 40 + Math.random() * (canvas.width - 80),
        y: 0,
        vy: 0.65 + Math.random() * 0.35
      });
    }
  }

  function cleanTank() {
    state.cleanliness = Math.min(100, state.cleanliness + 30);
    showNotification("Akvaryum temizlendi!");
  }

  function buyItem(type) {
    const prices = { filter: 500, heater: 300, plant: 100 };
    if (state.money < prices[type]) return showNotification("Bütçe yetmiyor!");
    state.money -= prices[type];

    if (type === "plant") {
      state.plants.push({ x: 50 + Math.random() * (canvas.width - 100), h: 40 + Math.random() * 60 });
    } else {
      state.items[type] = true;
      const btn = document.getElementById("buy" + type.charAt(0).toUpperCase() + type.slice(1));
      if (btn) btn.disabled = true;
      if (type === "heater") document.getElementById("tempSlider").disabled = false;
    }
    showNotification("Eşya alındı!");
  }

  function resetGame() { location.reload(); }

  function updateLogic(dtMs) {
    const now = Date.now();
    const dtSec = dtMs / 1000;

    if (state.items.heater) {
      const target = state.targetTemp;
      state.temp += (target - state.temp) * (0.018 * dtSec * 60);
    } else {
      state.temp += (20 - state.temp) * (0.0012 * dtSec * 60);
    }

    if (state.items.heater) state.targetTemp = parseInt(document.getElementById("tempSlider").value, 10);

    let basePollution = (state.creatures.length * 0.00055) * (dtSec * 60);
    if (state.items.filter) {
      basePollution *= 0.35;
      if (state.cleanliness < 82) state.cleanliness += 0.020 * (dtSec * 60);
    }
    state.cleanliness = clamp(state.cleanliness - basePollution, 0, 100);

    if (state.cleanliness > 60 && Math.abs(state.temp - 24) < 5) {
      state.money += (state.creatures.length * MONEY_PER_CREATURE_PER_SEC) * (dtSec * 60);
    }

    for (const f of state.foods) {
      f.y += f.vy * (dtSec * 60);
      if (f.y > canvas.height - 62) f.y = canvas.height - 62;
    }

    state.poops = state.poops.filter(p => (now - p.born) < 90 * 1000);
    for (const p of state.poops) {
      p.y += p.vy * (dtSec * 60);
      if (p.y > canvas.height - 62) p.y = canvas.height - 62;
    }

    state.creatures = state.creatures.filter(c => c.update(dtMs));

    const females = state.creatures.filter(c =>
      c.gender === "F" && (now - c.bornTime) > MATURITY_TIME && !c.isPregnant && c.energy > 45
    );
    const males = state.creatures.filter(c =>
      c.gender === "M" && (now - c.bornTime) > MATURITY_TIME && c.energy > 45
    );

    for (const f of females) {
      for (const m of males) {
        if (Math.hypot(f.x - m.x, f.y - m.y) >= 44) continue;
        if (now - f.lastBreedAttempt <= 20000) continue;

        f.lastBreedAttempt = now;

        const df = computeDerived(f);
        const env = envMods(state.temp, state.cleanliness);

        const compat = 1 - Math.abs(f.pheno - m.pheno);
        const chance = 0.12 * df.fertility * env.fertility * (0.55 + 0.85 * compat);

        if (Math.random() < chance) {
          f.isPregnant = true;
          f.pregnancyStartTime = now;

          const mix = (f.pheno + m.pheno) / 2;
          f._babyPheno = clamp(mix + (Math.random() - 0.5) * 0.08, 0, 1);
          f._babyTrait = (Math.random() < 0.6) ? f.trait : m.trait;
        }
      }
    }

    document.getElementById("moneyText").innerText = Math.floor(state.money) + " ₺";
    document.getElementById("tempText").innerText = state.temp.toFixed(1) + "°C";
    document.getElementById("cleanText").innerText = Math.floor(state.cleanliness) + "%";
    document.getElementById("fishCountText").innerText = state.creatures.length;
    document.getElementById("foodCountText").innerText = state.foods.length;
    document.getElementById("poopCountText").innerText = state.poops.length;
    document.getElementById("aquarium-timer").innerText = "Süre: " + formatTime(now - state.startTime);
  }

  function draw(ts) {
    const dtMs = Math.min(50, ts - state.lastTick);
    state.lastTick = ts;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (const p of state.plants) {
      ctx.fillStyle = "#166534";
      ctx.beginPath();
      ctx.moveTo(p.x, canvas.height - 60);
      ctx.quadraticCurveTo(p.x + 10, canvas.height - 60 - p.h/2, p.x, canvas.height - 60 - p.h);
      ctx.quadraticCurveTo(p.x - 10, canvas.height - 60 - p.h/2, p.x, canvas.height - 60);
      ctx.fill();
    }

    ctx.fillStyle = "#fbbf24";
    for (const f of state.foods) {
      ctx.beginPath();
      ctx.arc(f.x, f.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.fillStyle = "rgba(15,23,42,0.6)";
    for (const p of state.poops) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.2, 0, Math.PI * 2);
      ctx.fill();
    }

    for (const c of state.creatures) c.draw();

    updateLogic(dtMs);
    requestAnimationFrame(draw);
  }

  window.onload = init;
  requestAnimationFrame(draw);
</script>
</body>
</html>
